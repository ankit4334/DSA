//java programming pratice set.
/* 

Extra Elements
Given an array of integers, find the total number of extras in it. 
So basically, If an element occurs k times in the array, then out of those k occurrences k-1 are extras. 
For example, if arr[] = {2, 2, 2, 1, 5, 5}, then it contains 3 extras.

Input Format

First line of input contains an integer N, denoting the size of array.
Next line contains N space separated elements, denoting the array elements.
Output Format

Print the total number of extras in the given array.
Constraints

  1 <= N <= 10^5
 -(10^9) <= arr[i] <= 10^9
Sample Input

4        // N
7 7 1 7  // arr[]
Sample Output

2

class Result {
  // Return the total number of extras in the given array
  static int getExtras(int[] arr) {
	Arrays.sort(arr);
    int c=0;
    for(int i=1;i<arr.length;i++){
      if(arr[i]==arr[i-1]){
        c++;
      }
    }
    return c;
  }
}


---------------------------------------------------------------------
Next Closest Fibonacci Number
Given an array of integers, determine the smallest positive integer (including zero) that needs to be inserted in the array, such that the sum of array elements become equal to the next closest Fibonacci number. For example, if arr[] = {1, 5, 3}, then inserting 4 in the array generates the overall sum as 13 (1 + 5 + 3 + 4), i.e. the next closest Fibonacci number.

Note: The first 2 terms of Fibonacci sequence are 0 and 1 respectively, and the new term can always be generated by adding the last two terms in the sequence i.e., F(n) = F(n-1) + F(n-2)

Input Format

First line of input contains an integer N, denoting the size of array.
Next line contains N space separated elements, denoting the array elements.
Output Format

Print the smallest non-negative integer as specified in the description.
Constraints

  1 <= N <= 10^5
 -100 <= arr[i] <= 10^9
Sample Input

3      // N
1 5 3  // arr[]
Sample Output

4

class Result {
  // Return the smallest non-negative integer as specified in the description
  static long nextClosestFib(int[] arr) {
	long sum=0;
    for(int i=0;i<arr.length;i++){
      sum+=arr[i];
    }
    long a=0,b=1,c=0;
    while(c<sum){
      c=a+b;
      a=b;
      b=c;
    }
    return c-sum;
  }
}

---------------------------------------------------------------------------------------------------------------------------------------



Thirteen Unique Characters
Some people may consider thirteen as unlucky, but for Mahesh it is the most luckiest number. He has a string, and he wants to check whether it contains at least 13 non-repeating characters or not. For example, if the string is "Hmmm21+@xyz640FFF" then the answer will be NO, because it contains less than 13 non-repeating characters which are: H, 2, 1, +, @, x, y, z, 6, 4, 0.

Input Format:

The first line of input contains an integer T, denoting the no of test cases. 
Each test cases contains one line, which contains a string.
Output Format:

For each test case, print YES if the string contains at least 13 non-repeating characters, else print NO.
Sample Input

2
Hmmm21+@xyz640FFF
AbcDefggg1287@omXXPS
Sample Output

NO
YES



class Result {
  // Return true if the string contains at least 13 non-repeating characters
  static boolean thirteenUniqueChars(String str) {
    char arr[]=str.toCharArray();
    HashMap<Character,Integer> map=new HashMap<>();
    for(int i=0;i<arr.length;i++){
      map.put(arr[i],map.getOrDefault(arr[i],0)+1);
    }
    int c=0;
    for(int val:map.values()){
        if(val<2){
            c++;
        }
    }
    //System.out.println(c);
    if(c>=13){
      return true;
    }
    return false;
  }
}




---------------------------------------------------------------------------------------------------------------------------------------


Talented Students
Given two lists representing the IDs of students who participated in the singing and drawing competitions respectively. Both the given lists are sorted in descending order, and your task is to find the IDs of talented students who participated in both the competitions, and print them in descending order.

Example :

singingList : {9, 6, 5, 3, 2}

drawingList : {8, 7, 6, 2, 1}

talentedStudents : {6, 2}

Input Format

First line contains an integer n, denoting the number of students participated in singing competition.
Second line contains n space separated integers, denoting the list of student IDs in singing competition.
Third line contains an integer m, denoting the number of students participated in drawing competition.
Fourth line contains m space separated integers, denoting the list of student IDs in drawing competition.
Output Format

Print the IDs of talented students in descending order, separated by space.
Constraints

1 <= n, m <= 10^8
1 <= singingList[i], drawingList[i] <= 10^9
Sample Input

5          // n
9 6 5 3 2  // singingList[]
5          // m
8 7 6 2 1  // drawingList[]
Sample Output

6 2



class Result {
  // Print the IDs of talented students in descending order, separated by space
  static void talentedStudents(int[] singingList, int[] drawingList) {
   HashSet<Integer> h=new HashSet<>();
   for(int i=0;i<singingList.length;i++){
     h.add(singingList[i]);
   }
    for(int i=0;i<drawingList.length;i++){
    if(h.contains(drawingList[i])){
      System.out.print(drawingList[i]+" ");
    }
   }
  }
}


---------------------------------------------------------------------------------------------------------------------------------------




Reach a single digit
Given a positive integer N, determine the number of times you must add the digits in it to reach a single digit. For example, if N = 347, then the answer is 2 because 3 + 4 + 7 = 14 and 1 + 4 = 5, i.e. we reached a single digit in 2 steps.

Input Format:

The first line of input contains an integer T, denoting the number of test cases.
Then T lines follow, each line contains an integer N.
Constraints:

1 ≤ T ≤ 100
1 ≤ N ≤ 10^15
Output Format:

For each test case, print the total steps to reach a single digit, in new line.
Sample Input

2 // No. of testcases
347
1999
Sample Output

2
3
Explanation

For N = 1999
1 + 9 + 9 + 9 = 28
2 + 8 = 10
﻿﻿1 + 0 = 1
In 3 steps we reached a si



// Return the total number of steps to reach a single digit
static int count(long n) {
  int c=0;
  while(n!=0){
    c++;
    n=n/10;
  }
  return c;
}
static int sum(long n) {
  int sum=0;
  while(n!=0){
    sum+=n%10;
    n=n/10;
  }
  return sum;
}
static int totalSteps(long N) {
  if(N<9){
    return 0;
  }
  int step=0;
  while(count(N)!=1){
    step++;
    N=sum(N);
  }
  return step;
}





---------------------------------------------------------------------------------------------------------------------------------------


Try balancing the scale
Two weights X and Y are placed on the two sides of a balance scale. Now, given a list of N available weights, check whether it is possible to balance the scale or not, by using at most only 2 weights from the given list.

Example 1:

If X = 3, Y = 7, weights[] = {2, 3, 5, 18, 4}

Then the answer is YES, because placing weight 4 on the left side will balance the scale.

Example 2:

If X = 5, Y = 8, weights[] = {2, 9, 4, 11, 6}

Then the answer is YES, because placing weight 9 on the left side and 6 on the right side will balance the scale.

Example 3:

If X = 4, Y = 8, weights[] = {2, 1, 1, 9, 7}

Then the answer is NO.

Input Format

First line will contain an integer T, denoting the number of test cases.
For each test case:
  First line will contain two positive integers denoting X and Y, respectively.
  Second line will contain an integer N, denoting the number of available weights.
  Third line will contain N space separated integers, denoting the list of weights.
Output Format

For each test case, print YES if the scale can be balanced, else print NO, in new lines.
Constraints

1 <= T <= 10
1 <= X, Y <= 10^6
1 <= N <= 10^5
1 <= weights[i] <= 10^5
Sample Input

3            // Test Cases
3 7          // X Y ﻿(test case 1)
5            // N 
2 3 5 18 4   // weights[]
5 8          // X Y ﻿(test case 2)
5            // N
﻿2 9 4 11 6   // weights[]
4 8          // X Y ﻿(test case 3)
5            // N
2 1 1 9 7    // ﻿weights[]
Sample Output

YES
YES
NO





class Result {
  static boolean balanceScale(int x, int y, int n, int weights[]) {
    // Write your code here
    if(x==y){
      return true;
    }
    if(x>y){
      int temp=x;
      x=y;
      y=temp;
    }
    int k=y-x;
    int[] hash = new int[1000001];
    for(int i=0;i<n;i++){
      if(weights[i]+x==y){
        return true;
      }
      else if(k-weights[i]>=0 && hash[k-weights[i]]==1){
        return true;
      }
      else if(k+weights[i]>=0 && hash[k+weights[i]]==1 ){
        return true;
      }
      else if(weights[i]-k>=0 && hash[weights[i]-k]==1){
        return true;
      }
      else{
        hash[weights[i]]=1;
      }
    }
    return false;
  }
}









---------------------------------------------------------------------------------------------------------------------------------------


Same Digits
Given a string representing an integer number num, find the next number greater than num using the same set of digits. If there is no greater number with the same set of digits possible, then print -1.

For example, if num = 1234, then the answer is 1243.

Input Format

First line contains T that denotes the number of test cases.
This is followed by T lines, each containing a string num(representing an integer).
Output Format

For each test case, print the next number greater than num having the same set of digits.
Constraints

1 ≤ T ≤ 45
0 ≤ num ≤ 10^100
All characters of num ∈ {0-9}
Sample Input

3     // Test Cases
1234  // num (testcase 1)
57    // num (testcase 2)
997   // ﻿num (testcase 3)
Sample Output

1243
75
-1

//   
//  * Complete the 'nextGreator' function below.
//  * @params
//  *   num -> number represented in a string format
//  *
//  * @return
//  *   string representing the next number greater than 'num'
//  *   having the same set of digits.
//  
class Result {
    public static String nextGreator(String num) {
       char[] numArray = num.toCharArray();
       
    //    int i = numArray.length - 2;
    //    int j = numArray.length - 1;
    //    if(numArray[i]<numArray[j]){
    //      char temp = numArray[i];
    //       numArray[i] = numArray[j];
    //       numArray[j] = temp;
    //    }
    //   else{
    //    return "-1";
    //   }
      
          int i = numArray.length - 2;
          while (i >= 0 && numArray[i] >= numArray[i + 1]) {
              i--;
          }
          if (i == -1) {
              return "-1";
          }
          int j = numArray.length - 1;
          while (numArray[j] <= numArray[i]) {
              j--;
          }
          char temp = numArray[i];
          numArray[i] = numArray[j];
          numArray[j] = temp;
          int left = i + 1;
          int right = numArray.length - 1;
          while (left < right) {
              temp = numArray[left];
              numArray[left] = numArray[right];
              numArray[right] = temp;
              left++;
              right--;
          }
          return new String(numArray);
    }
  }



---------------------------------------------------------------------------------------------------------------------------------------


Wave Pattern
Rohan loves to study the ocean waves by drawing various patterns. Today he decided to arrange a set of array elements in the form of a wave, i.e. a1 > a2 < a3 > a4 < a5 > …

Now, given an integer array, check whether its elements can be arranged in a wave pattern or not. For example, if the arr[] = {3, 2, 5, 2, 4, 7}, then a possible arrangement for a wave pattern will be: {5, 2, 7, 2, 4, 3}. But, if the arr[] = {3, 2, 2, 1, 2, 5, 2}, then NO possible arrangement will generate a wave pattern.



Your solution must be optimized otherwise you may get an error "Time Limit Exceeded".

﻿

Input Format

First line will contain an integer T, denoting the number of test cases.
For each test case:
  First line will contain an integer N, denoting the size of array.
  Second line will contain N space separated integers, denoting array elements.
Output Format

For each test case, print YES if the array can be arranged in a wave pattern, else print NO, in new lines.
Constraints

1 <= T <= 10
2 <= N <= 10^5
0 <= arr[i] <= 10^4
Sample Input

2              // Test Cases
6              // N (test case 1)
3 2 5 2 4 7    // arr[]
7              // N (test case 2)
﻿3 2 2 1 2 5 2  // arr[]
Sample Output

YES
NO


class Result {
  // Return true if the array can be arranged in a wave pattern, else return false
  static boolean wavePattern(int arr[], int N) {
    int mc=0;
    int me=0;
    int a[]=new int[10001];
    for(int i=0;i<N;i++){
      a[arr[i]]++;
      if(a[arr[i]]>mc){
        mc=a[arr[i]];
        me=arr[i];
      }
    }
    if(mc>N/2){
      if(mc==Math.ceil((float)N/2)){
        for(int i=0;i<N;i++){
          if(arr[i]>me){
            return false;
          }
        }
      }else{
        return false;
      }
    }
    return true;
  }
}






---------------------------------------------------------------------------------------------------------------------------------------


Find the winner in a lottery
N people gave their names in a lottery, out of which only one will be selected. The lottery system's algorithm to choose a winner is very simple, i.e. the person with the third largest name wins the lottery. For example, if the names array is ["raman", "peter", "himanshu", "amit"], then peter wins the lottery because "himanshu" is 8 letters long, and "raman" and "peter" are both 5, but the winner will be peter because it appeared as the last 5 letter word in the array. If names array was ["raman", "peter", "james", "ali"], then the winner should be james because the first three names are all 5 letters long, so the last one out of them wins.

Given an array containing the names of N people who bought a lottery, find the name of the winner in it.

Note: At least 3 people will buy the lottery, and each person's name will contain only lowercase English letters.

Input Format:

The first line contains an integer N, denoting the number of people who bought the lottery.
Each of next N lines contain a string, denoting the name of each person.
Constraints:

3 ≤ N ≤ 10^5
All characters in a name are lower case English letters.
Output Format:

Print the name of the winner.
 Sample Input 1

4
ram
john
lu
amit
 Sample Output 1

ram
Sample Input 2

4
mohan
peter
seema
james
Sample Output 2

seema



static String findWinner(List<String> names) {
    String f="";
    String s="";
    String l="";
    for(String name:names){
      if(name.length()>l.length()){
        l=name;
      }
      if(name.length()>s.length()){
        l=s;
        s=name;
      }
      if(name.length()>f.length()){
        s=f;
        f=name;
      }
    }
    return l;
  }






---------------------------------------------------------------------------------------------------------------------------------------


Nth Fibonacci number modulo M
Given 2 non negative integers n and m, find the nth Fibonacci number modulo m.

The nth Fibonacci number Fn = Fn-1 + Fn-2 (n > 1), where F0 = 0 and F1 = 1.

The Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …....

Input Format

First line of input will contain an integer T denoting the number of testcases.
Each of next T lines will contain two space separated integers denoting n and m respectively.
Output Format

Print the value of (nth Fibonacci number) % m. 
Constraints:

1 <= T <= 10
0 <= n <= 150
1 <= m <= (10^9)+7
Sample Input

2    // Testcases
4 8  // n m (testcase 1)
7 6  // n m (testcase 2)
Sample Output

3
1
Explanation:

F4 = 3, therefore 3 % 8 = 3
F7 = 13, therefore 13 % 6 = 1



class Result {
  static int nthFibonacciTerm(int n, int m) {
    if(n<=1){
      return n%m;
    }
    int a=0,b=1,c=0;
    for(int i=1;i<n;i++){
      c=(a+b)%m;
      a=b;
      b=c;
    }
    return c;
  }
}




---------------------------------------------------------------------------------------------------------------------------------------



Cut the chocolate smartly for maximum pieces
Mr. G wants to impress his sister by giving her a lot of chocolate pieces. Assume he has a giant rectangular chocolate bar. Now your task is to find the maximum number of chocolate pieces, that he can cut and give to his sister, keeping in mind the below given conditions:

The chocolate must be served as only 1 x 1 sized pieces
He can cut the chocolate bar exactly K times.


Complete the maxPieces() function in editor. It has 1 parameter i.e. an integer denoting the value of K, and it must return an integer denoting the maximum number of chocolate pieces that can be cut.

Input Format

The first line contains an integer T, denoting the number of test cases. 
Each of Next T lines contains an integer K.
Output Format

For each test case, return the maximum number of pieces(1 x 1 sized) that can be cut, given the value of K.
Constraints

1 <= T <= 100
0 <= K <= 10^9
Sample Input

3  // Test Cases
7
5
6
Sample Output

12
6
9
Explanation:

For the first test-case where K = 7, You have many options to get 12 pieces like 4 Horizontal and 3 vertical cuts or 3 Horizontal and 4 vertical cuts.
For the second test-case where K = 5, You need 3 Horizontal and 2 vertical cuts.
For the third test-case where K = 6, You need 3 Horizontal and 3 vertical cuts.


class Result {
  static long maxPieces(long k) {
    long a,b;
    if(k%2==0){
      a=k/2;
      b=a;
    }
    else{
      a=k/2;
      b=a+1;
    }
    return a*b;
  }
}





---------------------------------------------------------------------------------------------------------------------------------------


Distribute in Circle
n items are to be delivered in a circle of length l.

Find the position where the nth item will be delivered if we start from a given position p.

NOTE: Items are distributed at adjacent positions starting from p in clockwise direction.

Input Format:

First line contains an integer n that denotes the number of items.
Second line contains an integer l that denotes the length of the circle.
Third line contains an integer p that denotes the starting position.
Output Format:

Print the position where the nth item will be delivered starting from position p.
Constraints:

1 <= n <= 10^12
1 <= l <= 10^12
1 <= p <= 10^12
Sample Input 1

3  // n
7  // l
2  // p
Sample Output 1

4
Explanation 1

Given 3 items that need to be distributed in a circle of length 7, starting from position 2.
The 1st item will be placed at position 2.
The 2nd item will be placed at position 3.
The 3rd item will be placed at position 4.
Sample Input 2

5  // n
9  // l
7  // p
Sample Output 2

2
Explanation 2

Given 5 items that need to be distributed in a circle of length 9, starting from position 7.
The 1st item will be placed at position 7.
The 2nd item will be placed at position 8.
The 3rd item will be placed at position 9.
Now moving circularly, the 4rd item will be placed at position 1.
The 5rd item will be placed at position 2.


class Result {
  static long distribute(long n, long l, long p) {
    long pos=(n+p-1)%l;
    if(pos==0){
      pos=l;
    }
 	return pos;
  }
}






---------------------------------------------------------------------------------------------------------------------------------------




Saving the Earth with Binary Fever
The Earth is under a threat from the outer space and the superheroes are busy in their personal life. Meanwhile, you have to catch the enemy and destroy him. Enemy is N steps above from you (assume yourself on first level i.e. level 0). Due to your binary fever, you can jump only in power of 2 i.e. 1, 2, 4, 8, 16 etc. So to defeat the enemy as quickly as possible, what is the minimum number of jumps you have to make?

Example: N = 25

Now, to reach the level 25 as quickly as possible, you can first make a jump of 1 unit, then of 8 units and finally a jump of 16 units. Therefore, a minimum of 3 jumps are required. Note that, jumps need not to be in increasing sequence only i.e. if you want, you can jump 8 units first, then 1 unit and finally 16 units.



Your solution must be optimized otherwise you may get an error "Time Limit Exceeded".



Input Format

The first line contains the number of test cases T. Next each line contains a number N which is the level of enemy.
Constraints:

1 <= T <= 10
0 <= N <= 2^53
Output Format

For each test case, print the minimum number of jumps shall be made by you to save the Earth, in a new line.
Sample Input:

2  // Test Cases
3  // N (testcase 1)
7  // N (testcase 2)
Sample Output:

2
3
Explanation:

Level 3 can be achieved by making jumps of 1 and 2, so total 2 jumps required.
Level 7 can be achieved by making jumps of 1, 2 and 4, so total 3 jumps required.






class Result {
  // Return the minimum number of jumps 
  static int getMinJumps(long n) {
    int c=0;
    while(n>0){
      if(n%2==1){
        c++;
      }
      n=n/2;
    }
	return c;
  }
}


---------------------------------------------------------------------------------------------------------------------------------------
Find all pairs with sum K
Given a sorted list of N integers, find all distinct pairs of integers in the list with sum equal to a given number K, with O(n log n) or O(n) time complexity.

Complete the function below which takes the array and K as parameters and return the number of pairs if any and 0 otherwise.

Input Format:

First line of input will contain a positive integer T = number of test cases. Each test case will contain 2 lines.
First line of each test case contains two integers - N and K. 
Next line will contain N numbers separated by space in non-decreasing order.
Constraints:

1 ≤ T ≤ 10
1 ≤ N ≤ 10^5
-(10^9) ≤ arr[i], K ≤ 10^9
Output Format:

For each test case, print number of distinct pairs whose sum will be equal to k. A pair must have two numbers at different indices. 
Two pairs are different if at least one of the indices in them is uncommon. Indices - (2,3) and (3,2) are not distinct, but (2,3) and (2,4) are.
Sample Input

3  // Test Cases
10 11  // N K (testcase 1)
1 2 3 4 5 6 7 8 9 10
5 10   // N K (testcase 2)
2 4 6 8 10
6 27   // N K (testcase 3)
12 15 20 22 34 36
Sample Output

5
2
1





class Result {
  static int getPairsCount(int arr[], int n, int k) {
	HashMap<Integer,Integer> m=new HashMap<>();
    int c=0;
    for(int i=0;i<n;i++){
      int com=k-arr[i];
      if(m.containsKey(com)){
        c+=m.get(com);
      }
      m.put(arr[i],m.getOrDefault(arr[i],0)+1);
    }
    return c;
  }
}

---------------------------------------------------------------------------------------------------------------------------------------

Vowel Substrings
Given a string, count the number of substrings in it which starts from a vowel (‘a’, ‘e’, ‘i’, ‘o’, ‘u’, ‘A’, ‘E’, ‘I’, ‘O’, ‘U’).

As the number of the substrings can be very large, print the count modulo(%) 10007.

Input Format:

First line contains a string.
Output Format:

Print a single integer X % 10007, where X is the number of substrings in the given string that starts from a vowel.
Constraints:

1 <= lengthOf(string) <= 10^6
Sample Input

ACID
Sample Output

6
Explanation:

For str = “ACID”, the following are the 6 substrings that start from a vowel.
A, AC, ACI, ACID, I, ID
Therefore, the answer would be 6 % 10007 = 6


class Result {
  static int countVowelSubstr(String str) {
    char arr[]=str.toCharArray();
    int n=arr.length;
    int c=0;
    for(int i=0;i<n;i++){
      if(arr[i]=='A' || arr[i]=='I' || arr[i]=='E' || arr[i]=='O' || arr[i]=='U' || arr[i]=='a' || arr[i]=='i' || arr[i]=='e' || arr[i]=='o' || arr[i]=='u'){
        c+=(n-i);
        c=c% 10007;
      }
    }
    return c;
  }
}



---------------------------------------------------------------------------------------------------------------------------------------


Convert an Roman Number in to Integer
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Eleven is written as, XI, which is simply X + I. The number twenty eight is written as XXVIII, which is XX + V + III.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Your task is that given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: "IV"
Output: 4
Example 2:

Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 3:

Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
Sample Input

2  // no. of test cases
LVIII
MCMXCIV
Sample Output

58
1994


class Result {
  static int romanToInt(String str) {
    HashMap<Character,Integer> m=new HashMap<>();
    m.put('I',1);
    m.put('V',5);
    m.put('X',10);
    m.put('L',50);
    m.put('C',100);
    m.put('D',500);
    m.put('M',1000);
    int ans=m.get(str.charAt(str.length()-1));
    for(int i=str.length()-2;i>=0;i--){
      if(m.get(str.charAt(i))<m.get(str.charAt(i+1))){
        ans-=m.get(str.charAt(i));
      }else{
        ans+=m.get(str.charAt(i));
      }
    }
      return ans;
  }
}






---------------------------------------------------------------------------------------------------------------------------------------


class Result {
  static int romanToInt(String str) {
    HashMap<Character,Integer> m=new HashMap<>();
    m.put('I',1);
    m.put('V',5);
    m.put('X',10);
    m.put('L',50);
    m.put('C',100);
    m.put('D',500);
    m.put('M',1000);
    int ans=m.get(str.charAt(str.length()-1));
    for(int i=str.length()-2;i>=0;i--){
      if(m.get(str.charAt(i))<m.get(str.charAt(i+1))){
        ans-=m.get(str.charAt(i));
      }else{
        ans+=m.get(str.charAt(i));
      }
    }
      return ans;
  }
}


class Result
{
  public static String largestNumber(int[] nums, int n){
   String s[]=new String[nums.length];
        for(int i=0;i<nums.length;i++){
            s[i]=String.valueOf(nums[i]);
        }
        StringBuilder sb=new StringBuilder("");
        Arrays.sort(s,(a,b)->(b+a).compareTo(a+b));
        for(String str:s)
        {
            sb.append(str);
        }
        String result=sb.toString();
        return result.startsWith("0")?"0":result;
  }
}





all test case not working.



---------------------------------------------------------------------------------------------------------------------------------------


Sort an array of 0s, 1s and 2s
Given an array containing only 0s, 1s and 2s. Sort the array in O(n) time i.e. process the array only once to do this sorting.

Input Format:

First Line will contain an integer N denoting the array size.
Second line contains N numbers (0, 1, 2) separated by space.
Output Format:

Print the sorted array.
Sample Input

6
0 0 2 0 1 2
Sample Output

0 0 0 1 2 2

class Result {
  // Do not print anything, just sort the given array itself
  static void sorting012Array(int a[], int n) {
	int s=0;
    int m=0;
    int e=n-1;
    while(m<=e){
      if(a[m]==0){
        int t=a[m];
        a[m]=a[s];
        a[s]=t;
        s++;
        m++;
      }
      else if(a[m]==1){
        m++;
      }
      else{
        int t=a[m];
        a[m]=a[e];
        a[e]=t;
        e--;
      }
    }
  }
}



---------------------------------------------------------------------------------------------------------------------------------------


Find Majority Element in Array
Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times.

You may assume that the array is non-empty and and the contents of array are always positive

Complete the function given getMajorityElement() in the editor, that accepts an array & returns the majority element of the array.

Input Format

The first line of input contains an integer N, denoting the total elements in array
The second line contains N spaced integers , element of the array.
Constraints

1 <= n <= 10^5
1 <= arr[i] <= 10^9
Output Format

Print the majority element in a new line
Sample Input 1

7  // n
2 2 1 1 1 2 2  // arr[]
Sample Output 1

2  // majority element
Sample Input 2

5
1 2 3 4 1
Sample Output 2

-1
Explanation:

Since there is no majority element display -1


class Result {
  static int getMajorityElement(int[] a) {
	int c=1;
    int in=0;
    for(int i=1;i<a.length;i++){
      if(a[i]==a[in]){
        c++;
      }
      else{
        c--;
      }
      if(c==0){
        c=1;
        in=i;
      }
    }
   c=0;
    for(int i=0;i<a.length;i++){
      if(a[i]==a[in]){
        c++;
      }
    }
    if(c>a.length/2){
      return a[in];
    }
    return -1;
  }
}



//method 2

import java.util.*;
class Result {
  static int getMajorityElement(int[] nums) {
	HashMap<Integer,Integer> m=new HashMap<>();
    for(int i=0;i<nums.length;i++){
      m.put(nums[i],m.getOrDefault(nums[i],0)+1);
    }
    int ans=-1;
    int f=0;
    for(Integer val:m.keySet()){
      if(m.get(val)>nums.length/2){
        ans=val;
        f=1;
        break;
      }
    }
    if(f==0){
      return ans;
    }
    return ans;
  }
}


---------------------------------------------------------------------------------------------------------------------------------------

Maximum Frequency in a sequence
Given a list of integers, find out the number that has the highest frequency. If there are more than one such numbers, output the smaller one.

Input:

First line of input will contain an integer T = number of test cases. 
Each test case will contain two lines:
First line will contain an integer N = number of elements in the sequence. 
Next line will contain N space separated integers of sequence A.
Output:

For each test case, print on a single line, the smallest number with highest frequency in the sequence.
Constraints

1 <= T <= 100
1 <= N <= 10^5
0 <= A[i] <= 1000
Sample Input

3  // No. of test cases
7
2 4 5 2 3 2 4
6
1 2 1 1 2 1
10
1 1 1 1 1 1 1 1 1 1
Sample Output

2
1
1




class Result {
  static int maxFrequency(int a[], int n) {
	Arrays.sort(a);
    int cc=1;
    int mc=1;
    int ele=a[0];
    for(int i=1;i<n;i++){
      if(a[i]==a[i-1]){
        cc++;
      }
      else{
        cc=1;
      }
      if(cc>mc){
        mc=cc;
        ele=a[i-1];
      }
    }
    return ele;
  }
}

//method 02

class Result {
  static int maxFrequency(int A[], int n) {
	Arrays.sort(A);
    int cc=1;
    int mc=1;
    int res=A[0];
    for(int i=1;i<n;i++){
      if(A[i]==A[i-1]){
        cc++;
      }
      else{
        cc=1;
      }
      if(cc>mc){
        mc=cc;
        res=A[i-1];
      }
    }
    return res;
  }
}
---------------------------------------------------------------------------------------------------------------------------------------


Square root of a number
Given a number n, devise an algorithm to compute its square root.

Input Format:

First line will contain T=number of test case, next T lines will contains an integer n where n >=1.
Output Format:

For each test case, calculate and print the square root of n with 2 decimal places (Round to nearest numbers e.g. 4.472 to 4.47 & 3.157 to 3.16) in new lines.
There should be no space after each element.
Sample Input

6
36
16
9
20
1
11
Sample Output

6.00
4.00
3.00
4.47
1.00
3.32



// Do NOT change the class name
class Main
{
  public static void main(String[] args)
  {
     Scanner sc=new Scanner(System.in);
     int t=sc.nextInt();
     while(t!=0){
       int n=sc.nextInt();
       System.out.printf("%.2f",Math.sqrt(n));
       System.out.println();
       t--;
     }
  }
}



---------------------------------------------------------------------------------------------------------------------------------------

Continuous Subtraction Game
Given an array of N integers, and you are supposed to play a game with them which is as follows: continuously get the difference of adjacent integers (i.e. arr[i] - arr[i+1]; for all i ∈ [0, arrLength-2]), and create a new array of integers with them, now repeat the same process with the subsequent arrays until a single element is left, finally print that remaining element as the answer.

For example, if arr[] = {2, 3, 5, 7, 4}, then taking the difference of each adjacent element produces the following new array: {-1, -2, -2, 3}. Now, repeating the same process will generate the following arrays: {1, 0, -5} -> {1, 5} -> {-4}. Therefore, the final answer is -4.

Expected Time Complexity: O(N)

Input Format

First line of input contains an integer N, denoting the size of array.
Next line contains N space separated elements, denoting the array elements.
Output Format

Print the element that will be left in the array after the game ends.
Constraints

  2 <= N <= 50
 -100 <= arr[i] <= 100
Sample Input

5          // N
2 3 5 7 4  // arr[]
Sample Output

-4


class Result {
  // Return the element that will be left in the array after the game ends
  static long subtractionGame(long[] arr) {
    int n=arr.length;
    while(n!=1){
      long a[]=new long[n-1];
      for(int i=0;i<n-1;i++){
        a[i]=arr[i]-arr[i+1];
      }
      arr=a;
      n=arr.length;
    }
    return arr[0];
  }
}








---------------------------------------------------------------------------------------------------------------------------------------

Compatibility Test
Rohan and Aditi are about to get married, but before that they wanted to check their compatibility, so they decided to visit an astrologer. The astrologer asked them to think of a string in their mind, now according to him if Rohan's string occurs at the end of Aditi's string, then they are compatible otherwise not.

For example: If Aditi's string = "Face" and Rohan's string = "ace", then they are compatible because the second string occurs at the end of first string.

Complete the function areCompatible(aditi_str, rohan_str) which accepts two strings as parameter and returns 1 if rohan_str occurs at end of aditi_str and 0 otherwise.

Input Format:

The first line of input contains an integer T denoting the no of test cases . 
Then T test cases follow. Each test case contains two strings aditi_str, rohan_str. 
Output Format:

For each test case, print 0 or 1 in new lines.
Constraints:

1 <= T <= 10
Given two strings can contain any valid ASCII character.
Sample Input

2
CodeQuotient ent
Coding Code
Sample Output

1
0



class Result {
  static int areCompatible(String aditi_str, String rohan_str) {
   if(aditi_str.endsWith(rohan_str)){
     return 1;
   }
    return 0;
  }
}

//m2

class Result {
  static int areCompatible(String a, String r) {
   int ans=0;
    if(a.endsWith(r)){
      ans=1;
    }
    else{
      ans=0;
    }
    return ans;
  }
}


---------------------------------------------------------------------------------------------------------------------------------------



Product Array - Ignoring Self
Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.

For example, if our input was [2, 3, 5, 7], the expected output would be [105, 70, 42, 30].

Input Format

First line contains an integer n, denoting the size of array.
Second line contains n space separated integers, denoting array elements.
Output Format

Print the elements of the resultant array, separated by space.
Constraints

2 <= n <= 10^5
-30 <= arr[i] <= 30
Sample Input

4        // n
1 2 3 4  // arr[]
Sample Output

24 12 8 6
Explanation

24 = 2 * 3 * 4
12 = 1 * 3 * 4
8  = 1 * 2 * 4
6  = 1 * 2 * 3



class Result {
  static int[] productArray(int n, int[] arr) {
    int a[]=new int[n];
    int p=1;
    int c=0;
    for(int i=0;i<n;i++){
      if(arr[i]!=0){
        p*=arr[i];
      }
      else{
        c++;
      }
    }
    for(int i=0;i<n;i++){
      if(c==0){
        a[i]=p/arr[i];
      }
      else if(c==1){
        if(arr[i]==0){
          a[i]=p;
        }
      }
    }
    return a;
  }
}

//m2

class Result {
  static int[] productArray(int n, int[] arr) {
 int a[]=new int[n];
 int p=1;
    for(int i=0;i<n;i++){
      p=1;
      for(int j=0;j<n;j++){
        if(i!=j){
          p*=arr[j];
        }
      }
      a[i]=p;
    }
   return a;
    //int a[]=new int[n];
    //for(int i=0;i<n;i++){
    //  for(int j=0;j<n;j++){
    //    if(i!=j){
    //      a[i]=arr[i]*arr[j];
    //    }
    //  }
    //}
    //return a;
  }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Capitalize first letter of each word in a string
Write a program in which given a string as input, capitalize first letter of each word in it.

For example, if the string is "code quotient" , the output string will be "Code Quotient"

Complete the function capitalizeFirstChar() that accepts the string and performs the given operation.

Input Format

The first line of input consists number of testcases, T
The next T lines contains a string on which the said operation is to be performed
Output Format

For each testcase, print the string after doing the given operation
﻿Sample Input

2
code quotient
get better at coding
Sample Output

Code Quotient
Get Better At Coding


static String capitalizeFirstChar(String str) {
  char a[]=str.toCharArray();
  for(int i=0;i<a.length;i++){
    if(i==0 || a[i-1]==' '){
      a[i]=Character.toUpperCase(a[i]);
    }
  }
  return String.valueOf(a);
}





---------------------------------------------------------------------------------------------------------------------------------------
Intelligent Investing
Assume that there are N different companies operating in your city. All the local investors have decided to invest only in the most profitable companies, but on the contrary you decided to invest your money in the second most profitable company. Note that, the amount of money invested in a company is the same as the company's net profit.

Given an array, denoting the net profits of respective companies, you have to find the second most profitable company out of them, and print the value of its net profit.

Note: If all the companies are equally profitable, OR if the second most profitable company has negative net profit, then you will not make any investment, hence print 0.

Input Format

The first line will contain an integer T, denoting the number of test cases.
Each test case will contain the following inputs:
  First line contains an integer N, denoting the total number of companies in your city.
  Second line contains N space separated integers, each representing the net profits of the respective companies.
Constraints

  1 <= T <= 10
  2 <= N <= 10^5
 -1000 <= profits[i] <= 1000
Output Format

Print the integer value, representing the net profit of the second most profitable company.
Sample Input

2  // No. of test cases
5
30 210 100 40 70
5
40 -20 50 40 10
Sample Output

100
40

class Result {
  static int investMoney(int[] profits, int N) {
    int ma=Integer.MIN_VALUE;
    int sm=Integer.MIN_VALUE;
    for(int i=0;i<N;i++){
      if(profits[i]>ma){
        ma=profits[i];
      }
    }
    for(int i=0;i<N;i++){
      if(profits[i]>sm && ma!=profits[i]){
        sm=profits[i];
      }
    }
    if(sm<0){
      return 0;
    }
    return sm;
  }
}

---------------------------------------------------------------------------------------------------------------------------------------




String at end or not
Given two strings, check weather second string occurs at end of first string or not.

Complete the function strAtEnd(str,suffix) which accepts two strings as parameter and return 1 if str2 occurs at end of str1 and 0 otherwise.

Input Format:

The first line of input contains an integer T denoting the no of test cases . 
Then T test cases follow. Each test case contains two strings str1, str2. 
Output Format:

For each test case, print 0 or 1 in new lines.
Constraints:

1 <= T <= 10
Given two strings can contain any valid ASCII character.
Sample Input

2
CodeQuotient ent
Coding Code
Sample Output

1
0





class Result {
  static int strAtEnd(String str, String suffix) {
    if(str.endsWith(suffix)){
      return 1;
    }
    return 0;
  }
}


---------------------------------------------------------------------------------------------------------------------------------------
Find occurrences of palindrome words in a string
Write a function which given a string, count and return the palindrome words present in the string. A word in a string is separated with space(s).

Sample Input 1

Mom and Dad are my best friends
Sample Output 1

2
Explanation 1

﻿This string contains two palindrome words (i.e., Mom, Dad) so the count is 2.
Sample Input 2

mohit speaks english
Sample Output 2

0
Explanation 2

This string contains no p


static boolean pal(String str) {
  int s=0;
  int e=str.length()-1;
  while(s<=e){
    if(str.charAt(s)!=str.charAt(e)){
      return false;
    }
    else{
      s++;
      e--;
    }
  }
  return true;
}
static int countPalindrome(String str) {
  str=str.toUpperCase();
  String s[]=str.split(" ");
  int c=0;
  for(String w:s){
    if(pal(w)){
      c++;
    }
  }
   return c;
}
---------------------------------------------------------------------------------------------------------------------------------------
Making garden look beautiful
In a beautiful botanical garden, there is a special arrangement of plants along a path, and that arrangement is represented by an array 'A' of size 'N', indicating their respective heights. The garden will be more captivating if the sum of the heights of the first and last plant is maximized. As the gardener in charge, you have the authority to swap the positions of any two plants at the most once. Your objective is to determine the maximum value you can achieve for the sum of the heights of the first and last plant by swapping at most once.

For example, let's consider a scenario where 'N' is 5, and the initial array 'A' is [5, 3, 6, 3, 7]. By swapping the positions of plant 1 and 3 (1-based indexing), the array transforms to [6, 3, 5, 3, 7]. In this case, the sum of the heights of the first and last plant is maximized as 6 + 7 = 13.

Your goal is to find the optimal swap that maximizes the sum of the heights of the first and last plant, making the botanical garden more visually appealing and impressive.

Input Format

The first line will contain an integer T, denoting the number of test cases.
Each test case will contain the following inputs:
  First line contains an integer N, denoting the total number of plants.
  Second line contains N space separated integers, each representing the height of a respective plant.
Constraints

1 <= T <= 10
3 <= N <= 10^5
1 <= A[i] <= 10^5
Output Format

Print the maximum value you can achieve for the sum of the heights of the first and last plant by swapping at most once.
Sample Input

2  // No. of test cases
5
5 3 6 3 7
6
1 4 5 3 8 2
Sample Output

13
10

class Result {
  static int beautifulGarden(int[] a, int n) {
	int sum=a[0]+a[n-1];
    for(int i=1;i<n-1;i++){
      int maxsum=a[0]+a[i];
      maxsum=Integer.max(maxsum,a[i]+a[n-1]);
      sum=Integer.max(maxsum,sum);
    }
    return sum;
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
Swap first and last character of each word in a string
Write a program which given a string, swap first and last character of each word in it.

Complete the function swapFirstLastChar() that accepts a multiword string and swaps the first and last character of every word in it.

Note: Every two adjacent words in the given string will be separated by exactly one space character.

Input Format

The first line of input consists number of testcases, T
The next T lines contains a string on which the said operation is to be performed
Output Format

For each testcase, print the string after doing the given operatio
Sample Input

2
Code Quotient
Get better at coding
Sample Output

eodC tuotienQ
teG retteb ta godinc


static String sol(String str) {
    char a[]=str.toCharArray();
    int n=a.length-1;
    char t=a[0];
    a[0]=a[n];
    a[n]=t;
    return String.valueOf(a);
  }
  static String swapFirstLastChar(String str) {
    StringBuilder sb=new StringBuilder();
    String s[]=str.split(" ");
    for(String w:s){
      sb.append(sol(w));
      sb.append(" ");
    }
    return sb.toString().trim();
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
All row and all columns as zero
Given a matrix, you need to set every row that contains a 0 to all 0s and set every column that contains a 0 to all 0s.

Leave other unaffected elements as it is and change only affected elements to 0s.

Input Format:

Each test-case will begin with two number m and n where m = no. of rows and n = no. of columns. m rows will follow with n integers in each row separated by a space. 
Output Format:

For each test case, print the elements of 2-d array after above effect.
Constraints:

1 <= m <= 50
1 <= n <= 50
0 <= Mat[i][j] <= 100
Sample Input 1

3 3
4 5 6
7 0 9
1 1 1
Sample Output 1

4 0 6
0 0 0
1 0 1
Sample Input 2

5 5
1 0 1 1 0
0 1 1 1 0
1 1 1 1 1
1 0 1 1 1
1 1 1 1 1
Sample Output 2

0 0 0 0 0
0 0 0 0 0
0 0 1 1 0
0 0 0 0 0
0 0 1 1 0

class Result {
  static void makeAllZero(int mat[][], int r, int c) {
    int v[][]=new int[r][c];
    for(int i=0;i<r;i++){
      for(int j=0;j<c;j++){
        v[i][j]=mat[i][j];
      }
    }
    for(int i=0;i<r;i++){
      for(int j=0;j<c;j++){
        if(mat[i][j]==0){
          for(int k=0;k<c;k++){
           v[i][k]=0;
        }
        }
      }
    }
    for(int i=0;i<r;i++){
      for(int j=0;j<c;j++){
        if(mat[i][j]==0){
          for(int k=0;k<r;k++){
           v[k][j]=0;
        }
        }
      }
    }
    for(int i=0;i<r;i++){
      for(int j=0;j<c;j++){
        mat[i][j]=v[i][j];
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
Buy maximum toys possible
Amit wants to buy some toys for his sister. He has X rupees in his pocket. But he is confused to buy which toy and seeking your help.

Given an array consisting of cost of toys. Find the maximum number of toys he can buy with the amount X.

Note: He can buy only 1 quantity of a particular toy.

Input Format:

First Line will contain an integer denoting the Money available.
Second Line will contain an integer N denoting the total number of toys.
Third line contains N integers separated by space as costs.
Constraints:

1 <= X <= 10^9
1 <= N <= 10^5
1 <= cost[i] <= 10^9
Output Format:

Print the number of toys.
Sample Input

10           // X
5            // N
10 4 1 17 5  // cost[]
Sample Output

3
Explanation:

Amit can buy toy number 2, 3 and 5 which costs him 4+1+5=10 Rupees and fits in his budget.


class Result {
  static int maxToys(int cost[], int n, int X) {
    Arrays.sort(cost);
    int c=0;
    for(int i=0;i<n;i++){
      if(cost[i]<=X){
        c++;
        X-=cost[i];
      }
    }
    return c;
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
Family Photograph
N members of a family are lined up in the increasing order of their heights for a family photograph. But to click a better snap, the photographer decided to reverse their positions in the groups of k members each.

Given an array and an integer k, where each array element denotes the height of a person standing at the respective position originally. Your task is to print their heights according to their final position, after reversing in the groups of k.

For example, If the height's array is {1, 2, 3, 4, 5, 6, 7, 8, 9}, i.e. denoting the original positions of the family members, and k = 3, then their final positions should be {3, 2, 1, 6, 5, 4, 9, 8, 7}, i.e. after reversing them in the groups of 3 members each.

Note: The last group on the right side may contain less than k members.

Input Format

First Line will contain an integer N, denoting the number of family members.
Second line contains N space separated integers, denoting the height of members standing at their respective positions originally.
Third line contains an integer k.
Output Format

Print the final heights array after reversal.
Constraints

1 <= N <= 10^5
1 <= heights[i] <= 1000
1 <= k <= N
Sample Input

9                  // N
1 2 3 4 5 6 7 8 9  // heights[]
3                  // k
Sample Output

3 2 1 6 5 4 9 8 7

class Result {
  // Do not print anything, just reverse the given array itself, in the groups of k
  static void reverseInGroups(int[] heights, int n, int k) {
    for(int i=0;i<n;i=i+k){
      int s=i;
      int e=Math.min(i+k-1,n-1);
      while(s<=e){
        int t=heights[s];
        heights[s]=heights[e];
        heights[e]=t;
        s++;
        e--;
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
ASCII String
Given a string, your task is to convert every character in it, except the space characters, into their corresponding ASCII values. For example, if str = "Fan", then the output should be "7097110".

ASCII values of 'F', 'a' and 'n' are 70, 97 and 110 respectively.

Input Format:

The first line of input contains an integer T, denoting the no of test cases. 
Each test cases contains one line, which contains a string.
Output Format:

For each test case, print the string after converting its characters into their correcponding ASCII values.
Sample Input

3  // Test Cases
Fan
Hello World
A x Oh
Sample Output

7097110
72101108108111 87111114108100
65 120 79104


class Result {
  // Return the string after converting its characters into their correcponding ASCII values
  static String ASCII_String(String str) {
    StringBuilder sb=new StringBuilder();
    for(int i=0;i<str.length();i++){
      char c=str.charAt(i);
      if(c!=' '){
        sb.append((int)c);
      }
      else{
        sb.append(' ');
      }
    }
    return sb.toString();
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
Create a jumbled string
Given two strings a and b of arbitrary lengths, create a jumbled string from these and then return a single jumbled string. The jumbling operation on two strings is described as follows:

Append alternating characters from a and b, respectively, to some new string say jString.
Once all of the characters in one of the strings have been exhausted, append the remaining characters of the other string to the jString.
As an example, assume you have two strings: "abc" and "stuvwx". Alternate between the first and second strings as long as you can:

'a' + 's' + 'b' + 't' + 'c' + 'u'.

At this point you have traversed the first string and have generated "asbtcu". The remainder of the second string, "vwx" is now added to the end of the string, creating "asbtcuvwx".

Complete the function createJumbledString(), which takes two strings as input and return the jumbled string.

Input Format

The first line contains string a.
The second line contains string b.
Output Format

Print the jumbled string
Sample Input

abc
stuvwx
Sample Output

asbtcuvwx

static String createJumbledString(String a, String b) {
    StringBuilder sb=new StringBuilder();
    int A=a.length();
    int B=b.length();
    int i=0;
    int j=0;
    while(i<A && j<B){
      sb.append(a.charAt(i));
      sb.append(b.charAt(j));
      i++;
      j++;
    }
    while(i<A){
      sb.append(a.charAt(i));
      i++;
      }
    while(j<B){
      sb.append(b.charAt(j));
      j++;
    }
    return sb.toString();
  }
}
---------------------------------------------------------------------------------------------------------------------------------------
Perfect String
Given a string that contains only 4 type of letters i.e. a, b, x, and y. The string is said to be perfect if it satisfies the following conditions:

count of 'a' + count of 'b' in the given string must be odd.
count of 'x' + count of 'y' in the given string must be even.
Note: It is possible that in some string all the 4 type of letters are not present. for example, "aab" is also a perfect string because a_count = 2, b_count = 1, x_count = 0, y_count = 0 which satisfies the above conditions.

Complete the function isPerfect() in the editor. The function receives a string to test as parameter and must return true or false based on the fact that, whether the given string is perfect or not.

Input Format:

The first line contains an integer T, denoting the number of test cases.
Each test cases contains one line, which contains a string.
Output Format:

For each test case, print YES if the string is perfect, else print NO.
Sample Input

4
xaxbyyb
aabbxxyy
abaabxy
yyxaby
Sample Output

YES
NO
YES
NO
Explanation:

Only first and third strin


Perfect String
Given a string that contains only 4 type of letters i.e. a, b, x, and y. The string is said to be perfect if it satisfies the following conditions:

count of 'a' + count of 'b' in the given string must be odd.
count of 'x' + count of 'y' in the given string must be even.
Note: It is possible that in some string all the 4 type of letters are not present. for example, "aab" is also a perfect string because a_count = 2, b_count = 1, x_count = 0, y_count = 0 which satisfies the above conditions.

Complete the function isPerfect() in the editor. The function receives a string to test as parameter and must return true or false based on the fact that, whether the given string is perfect or not.

Input Format:

The first line contains an integer T, denoting the number of test cases.
Each test cases contains one line, which contains a string.
Output Format:

For each test case, print YES if the string is perfect, else print NO.
Sample Input

4
xaxbyyb
aabbxxyy
abaabxy
yyxaby
Sample Output

YES
NO
YES
NO
Explanation:

Only first and third strin
---------------------------------------------------------------------------------------------------------------------------------------
Check the strength of virus
A virology student while studying the DNA of a corona virus found that, if a gene x and gene y in its DNA are separated by exactly 3 places anywhere, at least once, then it will be a strong virus. Consider the DNA as a string of characters, where each character denotes a gene.

Now, given the DNA sequence of corona virus, check if its a strong virus or not.

For example, if virus_DNA = "txma yert", then print YES because gene 'x' and gene 'y' are exactly 3 distance apart, therefore it is a strong virus.

Note: The DNA genes are case sensitive.

Input Format:

The first line of input contains an integer T denoting the no of test cases. 
The second line of input contains a string, denoting the DNA of the virus.
Output Format:

For each test case, print YES if the virus is strong, else print NO.
Sample Input

3
txma yert
BMuxp ioqytB yxurN
xaxoerylm
Sample Output

YES
NO
YES



class Result {
  // Return true if the virus is found to be strong, else return false
  static boolean isStrong(String virus) {
    char a[]=virus.toCharArray();
    int f=0;
    for(int i=4;i<a.length;i++){
      if((a[i-4]=='x' && a[i]=='y') || (a[i-4]=='y' && a[i]=='x')){
        return true;
      }
    }
	return false;
  }
}


---------------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------------





---------------------------------------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------------------------







---------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------





---------------------------------------------------------------------------------------------------------------------------------------





---------------------------------------------------------------------------------------------------------------------------------------





---------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------







---------------------------------------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------------------------





---------------------------------------------------------------------------------------------------------------------------------------







---------------------------------------------------------------------------------------------------------------------------------------





---------------------------------------------------------------------------------------------------------------------------------------







---------------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------




*/